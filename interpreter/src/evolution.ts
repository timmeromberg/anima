/**
 * Evolution engine for the Anima interpreter.
 *
 * Supports `evolve { ... }` blocks that track fitness metrics,
 * generate candidate mutations, verify them, and apply the best.
 *
 * In v0.1, evolution is simulated: candidates are generated by the mock
 * LLM adapter, and mutations are applied within a single session.
 * Real evolution would persist across sessions via anima.lock.
 */

import {
  AnimaValue,
  mkString,
  mkFloat,
  mkInt,
  mkBool,
  mkList,
  mkNull,
  mkUnit,
  mkMap,
  valueToString,
} from './values';
import { Environment } from './environment';
import { getLLMAdapter } from './llm';

// ---------------------------------------------------------------------------
// Evolution types
// ---------------------------------------------------------------------------

export interface EvolutionRecord {
  /** Unique ID for this evolution session. */
  id: string;
  /** Name of the evolving function/agent. */
  name: string;
  /** Current version number. */
  version: number;
  /** Fitness metrics collected over invocations. */
  fitnessHistory: FitnessEntry[];
  /** The current strategy/implementation (as source text). */
  currentSource: string;
  /** Whether evolution is active. */
  active: boolean;
}

export interface FitnessEntry {
  timestamp: number;
  metrics: Map<string, number>;
  overallFitness: number;
}

// ---------------------------------------------------------------------------
// EvolutionEngine
// ---------------------------------------------------------------------------

export class EvolutionEngine {
  private records = new Map<string, EvolutionRecord>();
  private nextId = 1;

  /** Register a new evolving construct. */
  register(name: string, source: string): EvolutionRecord {
    const id = `evo-${this.nextId++}`;
    const record: EvolutionRecord = {
      id,
      name,
      version: 1,
      fitnessHistory: [],
      currentSource: source,
      active: true,
    };
    this.records.set(name, record);
    return record;
  }

  /** Record a fitness observation for an evolving construct. */
  recordFitness(name: string, metrics: Map<string, number>): void {
    let record = this.records.get(name);
    if (!record) {
      // Auto-register if not already tracked
      this.register(name, '');
      record = this.records.get(name)!;
    }

    // Compute overall fitness as weighted average of metrics
    let total = 0;
    let count = 0;
    for (const v of metrics.values()) {
      total += v;
      count++;
    }
    const overallFitness = count > 0 ? total / count : 0;

    record.fitnessHistory.push({
      timestamp: Date.now(),
      metrics: new Map(metrics),
      overallFitness,
    });
  }

  /** Get the current fitness of an evolving construct. */
  getFitness(name: string): number {
    const record = this.records.get(name);
    if (!record || record.fitnessHistory.length === 0) return 0;
    return record.fitnessHistory[record.fitnessHistory.length - 1].overallFitness;
  }

  /** Get the full evolution record. */
  getRecord(name: string): EvolutionRecord | undefined {
    return this.records.get(name);
  }

  /** Attempt an evolution step: generate candidate, verify, apply if better. */
  async evolve(name: string): Promise<boolean> {
    const record = this.records.get(name);
    if (!record || !record.active) return false;

    const adapter = getLLMAdapter();
    const currentFitness = this.getFitness(name);

    // Generate a candidate mutation via LLM
    const candidate = await adapter.generate(
      `Improve this Anima code for better performance/clarity. Current fitness: ${currentFitness}.\n\n${record.currentSource}`
    );

    // In v0.1, we accept the mutation if it's non-empty
    // Real evolution would re-run tests and compare fitness
    if (candidate && candidate.length > 0) {
      record.version++;
      record.currentSource = candidate;
      return true;
    }

    return false;
  }

  /** Pin the current version (prevent further evolution). */
  pin(name: string): void {
    const record = this.records.get(name);
    if (record) {
      record.active = false;
    }
  }

  /** Unpin an evolution record, re-enabling evolution. */
  unpin(name: string): void {
    const record = this.records.get(name);
    if (record) {
      record.active = true;
    }
  }

  /** Rollback to a previous version. */
  rollback(name: string): boolean {
    const record = this.records.get(name);
    if (!record || record.version <= 1) return false;
    record.version--;
    // In a real system, we'd restore from version history
    return true;
  }

  /** Get all evolution records. */
  all(): EvolutionRecord[] {
    return Array.from(this.records.values());
  }
}

// ---------------------------------------------------------------------------
// Global evolution engine
// ---------------------------------------------------------------------------

let globalEngine = new EvolutionEngine();

export function getEvolutionEngine(): EvolutionEngine {
  return globalEngine;
}

export function setEvolutionEngine(engine: EvolutionEngine): void {
  globalEngine = engine;
}

// ---------------------------------------------------------------------------
// Builtin registrations
// ---------------------------------------------------------------------------

export function registerEvolutionBuiltins(env: Environment): void {
  const { mkBuiltin } = require('./values');

  // evolveRegister(name, source) — register an evolving construct
  env.define('evolveRegister', mkBuiltin('evolveRegister', (args: AnimaValue[]) => {
    if (args.length < 2 || args[0].kind !== 'string' || args[1].kind !== 'string') {
      throw new Error('evolveRegister(name: String, source: String) expected');
    }
    const record = globalEngine.register(args[0].value, args[1].value);
    return mkString(record.id);
  }), false);

  // evolveFitness(name, metrics) — record fitness metrics
  env.define('evolveFitness', mkBuiltin('evolveFitness', (args: AnimaValue[]) => {
    if (args.length < 2 || args[0].kind !== 'string' || args[1].kind !== 'map') {
      throw new Error('evolveFitness(name: String, metrics: Map) expected');
    }
    const metrics = new Map<string, number>();
    for (const [k, v] of args[1].entries) {
      if (v.kind === 'int' || v.kind === 'float') {
        metrics.set(k, v.value);
      }
    }
    globalEngine.recordFitness(args[0].value, metrics);
    return mkUnit();
  }), false);

  // evolveGetFitness(name) — get current fitness score
  env.define('evolveGetFitness', mkBuiltin('evolveGetFitness', (args: AnimaValue[]) => {
    if (args.length < 1 || args[0].kind !== 'string') {
      throw new Error('evolveGetFitness(name: String) expected');
    }
    return mkFloat(globalEngine.getFitness(args[0].value));
  }), false);

  // evolvePin(name) — pin the current version
  env.define('evolvePin', mkBuiltin('evolvePin', (args: AnimaValue[]) => {
    if (args.length < 1 || args[0].kind !== 'string') {
      throw new Error('evolvePin(name: String) expected');
    }
    globalEngine.pin(args[0].value);
    return mkUnit();
  }), false);

  // evolveInfo(name) — get evolution info as a map
  env.define('evolveInfo', mkBuiltin('evolveInfo', (args: AnimaValue[]) => {
    if (args.length < 1 || args[0].kind !== 'string') {
      throw new Error('evolveInfo(name: String) expected');
    }
    const record = globalEngine.getRecord(args[0].value);
    if (!record) return mkNull();
    const entries = new Map<string, AnimaValue>();
    entries.set('id', mkString(record.id));
    entries.set('name', mkString(record.name));
    entries.set('version', mkInt(record.version));
    entries.set('active', mkBool(record.active));
    entries.set('fitness', mkFloat(globalEngine.getFitness(record.name)));
    entries.set('historySize', mkInt(record.fitnessHistory.length));
    return mkMap(entries);
  }), false);

  // Friendly aliases
  env.define('pin', mkBuiltin('pin', (args: AnimaValue[]) => {
    if (args.length < 1 || args[0].kind !== 'string') throw new Error('pin(name: String) expected');
    globalEngine.pin(args[0].value);
    return mkUnit();
  }), false);

  env.define('unpin', mkBuiltin('unpin', (args: AnimaValue[]) => {
    if (args.length < 1 || args[0].kind !== 'string') throw new Error('unpin(name: String) expected');
    globalEngine.unpin(args[0].value);
    return mkUnit();
  }), false);

  env.define('trackFitness', mkBuiltin('trackFitness', (args: AnimaValue[]) => {
    if (args.length < 2 || args[0].kind !== 'string') throw new Error('trackFitness(name: String, score: Float) expected');
    const score = args[1].kind === 'int' || args[1].kind === 'float' ? args[1].value : 0;
    const metrics = new Map<string, number>();
    metrics.set('score', score);
    globalEngine.recordFitness(args[0].value, metrics);
    return mkUnit();
  }), false);

  env.define('getFitness', mkBuiltin('getFitness', (args: AnimaValue[]) => {
    if (args.length < 1 || args[0].kind !== 'string') throw new Error('getFitness(name: String) expected');
    return mkFloat(globalEngine.getFitness(args[0].value));
  }), false);
}
